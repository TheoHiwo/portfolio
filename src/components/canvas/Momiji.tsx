/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { Html, OrbitControls, PerspectiveCamera, useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useRef, useState } from "react";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import { useCanvasStore } from "./canvasStore";

//meshes imports
import MomijiMouse from "./MomijiMouse";
import MomijiScreen from "./MomijiScreen";
import { useGesture } from "@use-gesture/react";
import { animated, useSpring } from "@react-spring/three";

const MODEL = "momiji";

type GLTFResult = GLTF & {
  nodes: {
    root_d: THREE.Mesh;
    root_d_1: THREE.Mesh;
    Button_Home: THREE.Mesh;
    Button_Arrow_bottom: THREE.Mesh;
    Button_Arrow_left: THREE.Mesh;
    Button_Arrow_right: THREE.Mesh;
    Button_Arrow_top: THREE.Mesh;
    Button_FullScreen: THREE.Mesh;
    Mouse: THREE.Mesh;
    Screen: THREE.Mesh;
  };
  materials: {
    Texture: THREE.MeshBasicMaterial;
    Foliage: THREE.MeshBasicMaterial;
  };
};

const cameraArgs = {
  default: { position: [-5, 0, 40], rotation: [0, 0, 0], fov: 25 },
  fullScreen: { position: [0, 0, 40], rotation: [0, 0, 0], fov: 25 },
};

export default function Momiji(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/" + MODEL + ".glb") as GLTFResult;
  const group = useRef(null);

  const isMouseGrabbed = useCanvasStore((state) => state.isMouseGrabbed);
  const isFullScreen = useCanvasStore((state) => state.isFullScreen);
  const isRotatable = !isMouseGrabbed && !isFullScreen;
  const setSectionNumber = useCanvasStore((state) => state.setSectionNumber);
  const incrementSectionNumber = useCanvasStore((state) => state.incrementSectionNumber);
  const decrementSectionNumber = useCanvasStore((state) => state.decrementSectionNumber);


  let positionCameraZ = 40
  let targetCameraY = 4
  let targetCameraX = -2

  function cameraMediaQuery(x) {
    if (x.matches) { // If media query matches
      positionCameraZ = 70
      targetCameraY = 7
      targetCameraX = -0.9
    } else {
      positionCameraZ = 40
      targetCameraY = 4
      targetCameraX = 0
    }
  }
  
  const mobileBreakpoint = window.matchMedia("(max-width: 700px)")
  cameraMediaQuery(mobileBreakpoint) // Call listener function at run time
  mobileBreakpoint.addEventListener("change", cameraMediaQuery); // Attach listener function on state changes



  return (
    <group ref={group} {...props} dispose={null}>
      <mesh geometry={nodes.root_d.geometry} material={materials.Texture} />
      <mesh geometry={nodes.root_d_1.geometry} material={materials.Foliage} />
      <MomijiScreen geometry={nodes.Screen.geometry} material={materials.Texture} />
      <MomijiMouse geometry={nodes.Mouse.geometry} material={materials.Texture} />

      <mesh
        geometry={nodes.Button_Home.geometry}
        material={materials.Texture}
        position={[-3.79, 0.32, 8.92]}
        rotation={[2.94, -1.32, 2.82]}
        onPointerMove={handleKeyPointerOver}
        onPointerLeave={() => {document.body.style.cursor = "auto"}}
        onClick={() => {setSectionNumber(0)}}
        
      >
        <mesh geometry={nodes.Button_Arrow_bottom.geometry} material={materials.Texture} 
        onPointerMove={handleKeyPointerOver}
        onPointerLeave={(e) => {
          e.stopPropagation()
          document.body.style.cursor = "auto"
        }}
        onClick={(e) => {
          e.stopPropagation()
          incrementSectionNumber()
        }}
        />
        <mesh geometry={nodes.Button_Arrow_left.geometry} material={materials.Texture}  
        onPointerMove={(e) => {e.stopPropagation()}}
        onPointerLeave={(e) => {e.stopPropagation()}}
        onClick={(e) => {e.stopPropagation()}}
        />
        <mesh geometry={nodes.Button_Arrow_right.geometry} material={materials.Texture}  
        onPointerMove={(e) => {e.stopPropagation()}}
        onPointerLeave={(e) => {e.stopPropagation()}}
        onClick={(e) => {e.stopPropagation()}}
        />
        <mesh geometry={nodes.Button_Arrow_top.geometry} material={materials.Texture}  
        onPointerMove={handleKeyPointerOver}
        onPointerLeave={(e) => {
          e.stopPropagation()
          document.body.style.cursor = "auto"
        }}
        onClick={(e) => {
          e.stopPropagation()
          decrementSectionNumber()
        }}
        />
        <mesh geometry={nodes.Button_FullScreen.geometry} material={materials.Texture}  
        onPointerMove={(e) => {e.stopPropagation()}}
        onPointerLeave={(e) => {e.stopPropagation()}}
        onClick={(e) => {e.stopPropagation()}}
        />
      </mesh>

        <PerspectiveCamera
          makeDefault
          position={[-5, 0, positionCameraZ]}
          rotation={[0, 0, 0]}
          fov={25}
        />

      <OrbitControls
        maxPolarAngle={Math.PI / 2.3}
        minPolarAngle={Math.PI / 2.3}
        target={[targetCameraX, targetCameraY, 0]}
        enabled={isRotatable}
        enableZoom={false}
        enablePan={isRotatable}
      />
    </group>
  );
}

useGLTF.preload("/" + MODEL + ".glb");

//model cli compression
/* 
gltf-transform dedup momiji.glb momiji.glb
gltf-transform prune momiji.glb momiji.glb
gltf-transform flatten momiji.glb momiji.glb
gltf-transform quantize momiji.glb momiji.glb
gltf-transform draco momiji.glb momiji.glb
gltf-transform unlit momiji.glb momiji.glb
gltf-transform webp momiji.glb momiji.glb
 */

function handleKeyPointerOver(e) {
//   if( e.target !== e.currentTarget ) {
//     return;
// }
  // e.stopPropagation();
  document.body.style.cursor = "pointer";
}

// function handleDisablePointerOver(e) {
//   e.stopPropagation();
//   document.body.style.cursor = "disable";
// }
